/* automatically generated by rust-bindgen */

use libc::*;

use libarchive3_sys::ffi::Struct_archive as archive;
use libarchive3_sys::ffi::Struct_archive_entry as archive_entry;

use errors::alpm_errno_t;
use list::alpm_list_t;

// Opaque types
pub enum alpm_handle_t {}
pub enum alpm_db_t {}
pub enum alpm_pkg_t {}
pub enum alpm_trans_t {}
pub enum va_list {}

pub type alpm_time_t = i64;

/// Package install reasons.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_pkgreason_t {
    /// Explicitly requested by the user.
    ALPM_PKG_REASON_EXPLICIT = 0,
    /// Installed as a dependency for another package.
    ALPM_PKG_REASON_DEPEND = 1,
}

/// Location a package object was loaded from.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_pkgfrom_t {
    ALPM_PKG_FROM_FILE = 1,
    ALPM_PKG_FROM_LOCALDB = 2,
    ALPM_PKG_FROM_SYNCDB = 3,
}

/// Method used to validate a package.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_pkgvalidation_t {
    ALPM_PKG_VALIDATION_UNKNOWN = 0,
    ALPM_PKG_VALIDATION_NONE = 1,
    ALPM_PKG_VALIDATION_MD5SUM = 2,
    ALPM_PKG_VALIDATION_SHA256SUM = 4,
    ALPM_PKG_VALIDATION_SIGNATURE = 8,
}

/// Types of version constraints in dependency specs.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_depmod_t {
    /// No version constraint
    ALPM_DEP_MOD_ANY = 1,
    /// Test version equality (package=x.y.z)
    ALPM_DEP_MOD_EQ = 2,
    /// Test for at least a version (package>=x.y.z)
    ALPM_DEP_MOD_GE = 3,
    /// Test for at most a version (package<=x.y.z)
    ALPM_DEP_MOD_LE = 4,
    /// Test for greater than some version (package>x.y.z)
    ALPM_DEP_MOD_GT = 5,
    /// Test for less than some version (package<x.y.z)
    ALPM_DEP_MOD_LT = 6,
}

/// File conflict type.
/// Whether the conflict results from a file existing on the filesystem, or with
/// another target in the transaction.
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_fileconflicttype_t {
    ALPM_FILECONFLICT_TARGET = 1,
    ALPM_FILECONFLICT_FILESYSTEM = 2,
}

#[repr(u32)]
/// PGP signature verification options
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_siglevel_t {
    ALPM_SIG_PACKAGE = 1,
    ALPM_SIG_PACKAGE_OPTIONAL = 2,
    ALPM_SIG_PACKAGE_MARGINAL_OK = 4,
    ALPM_SIG_PACKAGE_UNKNOWN_OK = 8,
    ALPM_SIG_DATABASE = 1024,
    ALPM_SIG_DATABASE_OPTIONAL = 2048,
    ALPM_SIG_DATABASE_MARGINAL_OK = 4096,
    ALPM_SIG_DATABASE_UNKNOWN_OK = 8192,
    ALPM_SIG_USE_DEFAULT = 1073741824,
}

/// PGP signature verification status return codes
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_sigstatus_t {
    ALPM_SIGSTATUS_VALID = 0,
    ALPM_SIGSTATUS_KEY_EXPIRED = 1,
    ALPM_SIGSTATUS_SIG_EXPIRED = 2,
    ALPM_SIGSTATUS_KEY_UNKNOWN = 3,
    ALPM_SIGSTATUS_KEY_DISABLED = 4,
    ALPM_SIGSTATUS_INVALID = 5,
}

/// PGP signature verification status return codes
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_sigvalidity_t {
    ALPM_SIGVALIDITY_FULL = 0,
    ALPM_SIGVALIDITY_MARGINAL = 1,
    ALPM_SIGVALIDITY_NEVER = 2,
    ALPM_SIGVALIDITY_UNKNOWN = 3,
}

/// Dependency
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_depend_t {
    pub name: *mut c_char,
    pub version: *mut c_char,
    pub desc: *mut c_char,
    pub name_hash: c_ulong,
    pub mod_: alpm_depmod_t,
}

/// Missing dependency
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_depmissing_t {
    pub target: *mut c_char,
    pub depend: *mut alpm_depend_t,
    pub causingpkg: *mut c_char,
}

/// Conflict
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_conflict_t {
    pub package1_hash: c_ulong,
    pub package2_hash: c_ulong,
    pub package1: *mut c_char,
    pub package2: *mut c_char,
    pub reason: *mut alpm_depend_t,
}

/// File conflict
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_fileconflict_t {
    pub target: *mut c_char,
    pub type_: alpm_fileconflicttype_t,
    pub file: *mut c_char,
    pub ctarget: *mut c_char,
}

/// Package group
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_group_t {
    /// group name
    pub name: *mut c_char,
    /// list of alpm_pkg_t packages
    pub packages: *mut alpm_list_t,
}

/// Package upgrade delta
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_delta_t {
    /// filename of the delta patch
    pub delta: *mut c_char,
    /// md5sum of the delta file
    pub delta_md5: *mut c_char,
    /// filename of the 'before' file
    pub from: *mut c_char,
    /// filename of the 'after' file
    pub to: *mut c_char,
    /// filesize of the delta file
    pub delta_size: off_t,
    /// download filesize of the delta file
    pub download_size: off_t,
}

/// File in a package
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_file_t {
    pub name: *mut c_char,
    pub size: off_t,
    pub mode: mode_t,
}

/// Package filelist container
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_filelist_t {
    pub count: usize,
    pub files: *mut alpm_file_t,
}

/// Local package or package file backup entry
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_backup_t {
    pub name: *mut c_char,
    pub hash: *mut c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_pgpkey_t {
    pub data: *mut c_void,
    pub fingerprint: *mut c_char,
    pub uid: *mut c_char,
    pub name: *mut c_char,
    pub email: *mut c_char,
    pub created: alpm_time_t,
    pub expires: alpm_time_t,
    pub length: c_uint,
    pub revoked: c_uint,
    pub pubkey_algo: c_char,
}

/// Signature result. Contains the key, status, and validity of a given
/// signature.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_sigresult_t {
    pub key: alpm_pgpkey_t,
    pub status: alpm_sigstatus_t,
    pub validity: alpm_sigvalidity_t,
}

/// Signature list. Contains the number of signatures found and a pointer to an
/// array of results. The array is of size count.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_siglist_t {
    pub count: usize,
    pub results: *mut alpm_sigresult_t,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_hook_when_t {
    ALPM_HOOK_PRE_TRANSACTION = 1,
    ALPM_HOOK_POST_TRANSACTION = 2,
}

/// Logging Levels
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_loglevel_t {
    ALPM_LOG_ERROR = 1,
    ALPM_LOG_WARNING = 2,
    ALPM_LOG_DEBUG = 4,
    ALPM_LOG_FUNCTION = 8,
}

pub type alpm_cb_log = Option< unsafe extern "C" fn(
    arg1: alpm_loglevel_t,
    arg2: *const c_char,
    arg3: *const va_list,
    // arg3: *mut __va_list_tag,
)>;

extern "C" {
    pub fn alpm_logaction(
        handle: *mut alpm_handle_t,
        prefix: *const c_char,
        fmt: *const c_char,
        ...
    ) -> c_int;
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_event_type_t {
    /// Dependencies will be computed for a package.
    ALPM_EVENT_CHECKDEPS_START = 1,
    /// Dependencies were computed for a package.
    ALPM_EVENT_CHECKDEPS_DONE = 2,
    /// File conflicts will be computed for a package.
    ALPM_EVENT_FILECONFLICTS_START = 3,
    /// File conflicts were computed for a package.
    ALPM_EVENT_FILECONFLICTS_DONE = 4,
    /// Dependencies will be resolved for target package.
    ALPM_EVENT_RESOLVEDEPS_START = 5,
    /// Dependencies were resolved for target package.
    ALPM_EVENT_RESOLVEDEPS_DONE = 6,
    /// Inter-conflicts will be checked for target package.
    ALPM_EVENT_INTERCONFLICTS_START = 7,
    /// Inter-conflicts were checked for target package.
    ALPM_EVENT_INTERCONFLICTS_DONE = 8,
    /// Processing the package transaction is starting.
    ALPM_EVENT_TRANSACTION_START = 9,
    /// Processing the package transaction is finished.
    ALPM_EVENT_TRANSACTION_DONE = 10,
    /// Package will be installed/upgraded/downgraded/re-installed/removed; See
    /// alpm_event_package_operation_t for arguments.
    ALPM_EVENT_PACKAGE_OPERATION_START = 11,
    /// Package was installed/upgraded/downgraded/re-installed/removed; See
    /// alpm_event_package_operation_t for arguments.
    ALPM_EVENT_PACKAGE_OPERATION_DONE = 12,
    /// Target package's integrity will be checked.
    ALPM_EVENT_INTEGRITY_START = 13,
    /// Target package's integrity was checked.
    ALPM_EVENT_INTEGRITY_DONE = 14,
    /// Target package will be loaded.
    ALPM_EVENT_LOAD_START = 15,
    /// Target package is finished loading.
    ALPM_EVENT_LOAD_DONE = 16,
    /// Target delta's integrity will be checked.
    ALPM_EVENT_DELTA_INTEGRITY_START = 17,
    /// Target delta's integrity was checked.
    ALPM_EVENT_DELTA_INTEGRITY_DONE = 18,
    /// Deltas will be applied to packages.
    ALPM_EVENT_DELTA_PATCHES_START = 19,
    /// Deltas were applied to packages.
    ALPM_EVENT_DELTA_PATCHES_DONE = 20,
    /// Delta patch will be applied to target package; See
    /// alpm_event_delta_patch_t for arguments..
    ALPM_EVENT_DELTA_PATCH_START = 21,
    /// Delta patch was applied to target package.
    ALPM_EVENT_DELTA_PATCH_DONE = 22,
    /// Delta patch failed to apply to target package.
    ALPM_EVENT_DELTA_PATCH_FAILED = 23,
    /// Scriptlet has printed information; See alpm_event_scriptlet_info_t for
    /// arguments.
    ALPM_EVENT_SCRIPTLET_INFO = 24,
    /// Files will be downloaded from a repository.
    ALPM_EVENT_RETRIEVE_START = 25,
    /// Files were downloaded from a repository.
    ALPM_EVENT_RETRIEVE_DONE = 26,
    /// Not all files were successfully downloaded from a repository.
    ALPM_EVENT_RETRIEVE_FAILED = 27,
    /// A file will be downloaded from a repository; See alpm_event_pkgdownload_t
    /// for arguments
    ALPM_EVENT_PKGDOWNLOAD_START = 28,
    /// A file was downloaded from a repository; See alpm_event_pkgdownload_t
    /// for arguments
    ALPM_EVENT_PKGDOWNLOAD_DONE = 29,
    /// A file failed to be downloaded from a repository; See
    /// alpm_event_pkgdownload_t for arguments
    ALPM_EVENT_PKGDOWNLOAD_FAILED = 30,
    /// Disk space usage will be computed for a package.
    ALPM_EVENT_DISKSPACE_START = 31,
    /// Disk space usage was computed for a package.
    ALPM_EVENT_DISKSPACE_DONE = 32,
    /// An optdepend for another package is being removed; See
    /// alpm_event_optdep_removal_t for arguments.
    ALPM_EVENT_OPTDEP_REMOVAL = 33,
    /// A configured repository database is missing; See
    /// alpm_event_database_missing_t for arguments.
    ALPM_EVENT_DATABASE_MISSING = 34,
    /// Checking keys used to create signatures are in keyring.
    ALPM_EVENT_KEYRING_START = 35,
    /// Keyring checking is finished.
    ALPM_EVENT_KEYRING_DONE = 36,
    /// Downloading missing keys into keyring.
    ALPM_EVENT_KEY_DOWNLOAD_START = 37,
    /// Key downloading is finished.
    ALPM_EVENT_KEY_DOWNLOAD_DONE = 38,
    /// A .pacnew file was created; See alpm_event_pacnew_created_t for arguments.
    ALPM_EVENT_PACNEW_CREATED = 39,
    /// A .pacsave file was created; See alpm_event_pacsave_created_t for
    /// arguments
    ALPM_EVENT_PACSAVE_CREATED = 40,
    /// Processing hooks will be started.
    ALPM_EVENT_HOOK_START = 41,
    /// Processing hooks is finished.
    ALPM_EVENT_HOOK_DONE = 42,
    /// A hook is starting
    ALPM_EVENT_HOOK_RUN_START = 43,
    /// A hook has finished running
    ALPM_EVENT_HOOK_RUN_DONE = 44,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_any_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_package_operation_t {
    /// Package (to be) installed. (No oldpkg)
    ALPM_PACKAGE_INSTALL = 1,
    /// Package (to be) upgraded
    ALPM_PACKAGE_UPGRADE = 2,
    /// Package (to be) re-installed.
    ALPM_PACKAGE_REINSTALL = 3,
    /// Package (to be) downgraded.
    ALPM_PACKAGE_DOWNGRADE = 4,
    /// Package (to be) removed. (No newpkg)
    ALPM_PACKAGE_REMOVE = 5,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_package_operation_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Type of operation.
    pub operation: alpm_package_operation_t,
    /// Old package.
    pub oldpkg: *mut alpm_pkg_t,
    /// New package.
    pub newpkg: *mut alpm_pkg_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_optdep_removal_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Package with the optdep.
    pub pkg: *mut alpm_pkg_t,
    /// Optdep being removed.
    pub optdep: *mut alpm_depend_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_delta_patch_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Delta info
    pub delta: *mut alpm_delta_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_scriptlet_info_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Line of scriptlet output.
    pub line: *const c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_database_missing_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Name of the database.
    pub dbname: *const c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_pkgdownload_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Name of the file
    pub file: *const c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_pacnew_created_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Whether the creation was result of a NoUpgrade or not
    pub from_noupgrade: c_int,
    /// Old package.
    pub oldpkg: *mut alpm_pkg_t,
    /// New Package.
    pub newpkg: *mut alpm_pkg_t,
    /// Filename of the file without the .pacnew suffix
    pub file: *const c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_pacsave_created_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Old package.
    pub oldpkg: *mut alpm_pkg_t,
    /// Filename of the file without the .pacsave suffix.
    pub file: *const c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_hook_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Type of hooks.
    pub when: alpm_hook_when_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_event_hook_run_t {
    /// Type of event.
    pub type_: alpm_event_type_t,
    /// Name of hook
    pub name: *const c_char,
    /// Description of hook to be outputted
    pub desc: *const c_char,
    /// position of hook being run
    pub position: usize,
    /// total hooks being run
    pub total: usize,
}

/// Events.
/// This is an union passed to the callback, that allows the frontend to know
/// which type of event was triggered (via type). It is then possible to
/// typecast the pointer to the right structure, or use the union field, in order
/// to access event-specific data.
#[repr(C)]
#[derive(Copy, Clone)]
pub union alpm_event_t {
    pub type_: alpm_event_type_t,
    pub any: alpm_event_any_t,
    pub package_operation: alpm_event_package_operation_t,
    pub optdep_removal: alpm_event_optdep_removal_t,
    pub delta_patch: alpm_event_delta_patch_t,
    pub scriptlet_info: alpm_event_scriptlet_info_t,
    pub database_missing: alpm_event_database_missing_t,
    pub pkgdownload: alpm_event_pkgdownload_t,
    pub pacnew_created: alpm_event_pacnew_created_t,
    pub pacsave_created: alpm_event_pacsave_created_t,
    pub hook: alpm_event_hook_t,
    pub hook_run: alpm_event_hook_run_t,
    _bindgen_union_align: [u64; 5usize],
}

/// Event callback.
pub type alpm_cb_event = Option<unsafe extern "C" fn(arg1: *mut alpm_event_t)>;

/// Type of questions.
/// Unlike the events or progress enumerations, this enum has bitmask values
/// so a frontend can use a bitmask map to supply preselected answers to the
/// different types of questions.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_question_type_t {
    ALPM_QUESTION_INSTALL_IGNOREPKG = (1 << 0),
    ALPM_QUESTION_REPLACE_PKG = (1 << 1),
    ALPM_QUESTION_CONFLICT_PKG = (1 << 2),
    ALPM_QUESTION_CORRUPTED_PKG = (1 << 3),
    ALPM_QUESTION_REMOVE_PKGS = (1 << 4),
    ALPM_QUESTION_SELECT_PROVIDER = (1 << 5),
    ALPM_QUESTION_IMPORT_KEY = (1 << 6),
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_any_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer.
    pub answer: c_int,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_install_ignorepkg_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: whether or not to install pkg anyway.
    pub install: c_int,
    pub pkg: *mut alpm_pkg_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_replace_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: whether or not to replace oldpkg with newpkg.
    pub replace: c_int,
    pub oldpkg: *mut alpm_pkg_t,
    pub newpkg: *mut alpm_pkg_t,
    pub newdb: *mut alpm_db_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_conflict_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: whether or not to remove conflict->package2.
    pub remove: c_int,
    /// Conflict info.
    pub conflict: *mut alpm_conflict_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_corrupted_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: whether or not to remove filepath.
    pub remove: c_int,
    /// Filename to remove
    pub filepath: *const c_char,
    /// Error code indicating the reason for package invalidity
    pub reason: alpm_errno_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_remove_pkgs_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: whether or not to skip packages.
    pub skip: c_int,
    /// List of alpm_pkg_t* with unresolved dependencies.
    pub packages: *mut alpm_list_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_select_provider_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: which provider to use (index from providers).
    pub use_index: c_int,
    /// List of alpm_pkg_t* as possible providers.
    pub providers: *mut alpm_list_t,
    /// What providers provide for.
    pub depend: *mut alpm_depend_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alpm_question_import_key_t {
    /// Type of question.
    pub type_: alpm_question_type_t,
    /// Answer: whether or not to import key.
    pub import: c_int,
    /// The key to import.
    pub key: *mut alpm_pgpkey_t,
}

/// Questions.
/// This is an union passed to the callback, that allows the frontend to know
/// which type of question was triggered (via type). It is then possible to
/// typecast the pointer to the right structure, or use the union field, in order
/// to access question-specific data.
#[repr(C)]
#[derive(Copy, Clone)]
pub union alpm_question_t {
    pub type_: alpm_question_type_t,
    pub any: alpm_question_any_t,
    pub install_ignorepkg: alpm_question_install_ignorepkg_t,
    pub replace: alpm_question_replace_t,
    pub conflict: alpm_question_conflict_t,
    pub corrupted: alpm_question_corrupted_t,
    pub remove_pkgs: alpm_question_remove_pkgs_t,
    pub select_provider: alpm_question_select_provider_t,
    pub import_key: alpm_question_import_key_t,
    _bindgen_union_align: [u64; 4usize],
}

/// Question callback
pub type alpm_cb_question = Option<unsafe extern "C" fn(arg1: *mut alpm_question_t)>;

/// Progress
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_progress_t {
    ALPM_PROGRESS_ADD_START = 0,
    ALPM_PROGRESS_UPGRADE_START = 1,
    ALPM_PROGRESS_DOWNGRADE_START = 2,
    ALPM_PROGRESS_REINSTALL_START = 3,
    ALPM_PROGRESS_REMOVE_START = 4,
    ALPM_PROGRESS_CONFLICTS_START = 5,
    ALPM_PROGRESS_DISKSPACE_START = 6,
    ALPM_PROGRESS_INTEGRITY_START = 7,
    ALPM_PROGRESS_LOAD_START = 8,
    ALPM_PROGRESS_KEYRING_START = 9,
}

/// Progress callback
pub type alpm_cb_progress = Option<
    unsafe extern "C" fn(
        arg1: alpm_progress_t,
        arg2: *const c_char,
        arg3: c_int,
        arg4: usize,
        arg5: usize,
    )>;
/// Type of download progress callbacks.
/// @param filename the name of the file being downloaded
/// @param xfered the number of transferred bytes
/// @param total the total number of bytes to transfer
pub type alpm_cb_download = Option<unsafe extern "C" fn(filename: *const c_char, xfered: off_t, total: off_t)>;

pub type alpm_cb_totaldl = Option<unsafe extern "C" fn(total: off_t)>;
/// A callback for downloading files
/// @param url the URL of the file to be downloaded
/// @param localpath the directory to which the file should be downloaded
/// @param force whether to force an update, even if the file is the same
/// Returns 0 on success, 1 if the file exists and is identical, -1 on
/// error.
pub type alpm_cb_fetch = Option<
    unsafe extern "C" fn(
        url: *const c_char,
        localpath: *const c_char,
        force: c_int,
    ) -> c_int>;
extern "C" {
    /// Fetch a remote pkg.
    ///
    /// @param url URL of the package to download
    /// Returns the downloaded filepath on success, NULL on error
    pub fn alpm_fetch_pkgurl(
        handle: *mut alpm_handle_t,
        url: *const c_char,
    ) -> *mut c_char;

    /// Returns the callback used for logging.
    pub fn alpm_option_get_logcb(handle: *mut alpm_handle_t) -> alpm_cb_log;

    /// Sets the callback used for logging.
    pub fn alpm_option_set_logcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_log,
    ) -> c_int;

    /// Returns the callback used to report download progress.
    pub fn alpm_option_get_dlcb(handle: *mut alpm_handle_t) -> alpm_cb_download;

    /// Sets the callback used to report download progress.
    pub fn alpm_option_set_dlcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_download,
    ) -> c_int;

    /// Returns the downloading callback.
    pub fn alpm_option_get_fetchcb(handle: *mut alpm_handle_t) -> alpm_cb_fetch;

    /// Sets the downloading callback.
    pub fn alpm_option_set_fetchcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_fetch,
    ) -> c_int;

    /// Returns the callback used to report total download size.
    pub fn alpm_option_get_totaldlcb(handle: *mut alpm_handle_t) -> alpm_cb_totaldl;

    /// Sets the callback used to report total download size.
    pub fn alpm_option_set_totaldlcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_totaldl,
    ) -> c_int;

    /// Returns the callback used for events.
    pub fn alpm_option_get_eventcb(handle: *mut alpm_handle_t) -> alpm_cb_event;

    /// Sets the callback used for events.
    pub fn alpm_option_set_eventcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_event,
    ) -> c_int;

    /// Returns the callback used for questions.
    pub fn alpm_option_get_questioncb(handle: *mut alpm_handle_t) -> alpm_cb_question;

    /// Sets the callback used for questions.
    pub fn alpm_option_set_questioncb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_question,
    ) -> c_int;

    /// Returns the callback used for operation progress.
    pub fn alpm_option_get_progresscb(handle: *mut alpm_handle_t) -> alpm_cb_progress;

    /// Sets the callback used for operation progress.
    pub fn alpm_option_set_progresscb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_progress,
    ) -> c_int;

    /// Returns the root of the destination filesystem. Read-only.
    pub fn alpm_option_get_root(handle: *mut alpm_handle_t) -> *const c_char;

    /// Returns the path to the database directory. Read-only.
    pub fn alpm_option_get_dbpath(handle: *mut alpm_handle_t) -> *const c_char;

    /// Get the name of the database lock file. Read-only.
    pub fn alpm_option_get_lockfile(handle: *mut alpm_handle_t) -> *const c_char;

    /// @name Accessors to the list of package cache directories.
    /// @{
    pub fn alpm_option_get_cachedirs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_set_cachedirs(
        handle: *mut alpm_handle_t,
        cachedirs: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_add_cachedir(
        handle: *mut alpm_handle_t,
        cachedir: *const c_char,
    ) -> c_int;

    pub fn alpm_option_remove_cachedir(
        handle: *mut alpm_handle_t,
        cachedir: *const c_char,
    ) -> c_int;

    /// @name Accessors to the list of package hook directories.
    /// @{
    pub fn alpm_option_get_hookdirs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_set_hookdirs(
        handle: *mut alpm_handle_t,
        hookdirs: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_add_hookdir(
        handle: *mut alpm_handle_t,
        hookdir: *const c_char,
    ) -> c_int;

    pub fn alpm_option_remove_hookdir(
        handle: *mut alpm_handle_t,
        hookdir: *const c_char,
    ) -> c_int;

    /// @}
    pub fn alpm_option_get_overwrite_files(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_set_overwrite_files(
        handle: *mut alpm_handle_t,
        globs: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_add_overwrite_file(
        handle: *mut alpm_handle_t,
        glob: *const c_char,
    ) -> c_int;

    pub fn alpm_option_remove_overwrite_file(
        handle: *mut alpm_handle_t,
        glob: *const c_char,
    ) -> c_int;

    /// Returns the logfile name.
    pub fn alpm_option_get_logfile(handle: *mut alpm_handle_t) -> *const c_char;

    /// Sets the logfile name.
    pub fn alpm_option_set_logfile(
        handle: *mut alpm_handle_t,
        logfile: *const c_char,
    ) -> c_int;

    /// Returns the path to libalpm's GnuPG home directory.
    pub fn alpm_option_get_gpgdir(handle: *mut alpm_handle_t) -> *const c_char;

    /// Sets the path to libalpm's GnuPG home directory.
    pub fn alpm_option_set_gpgdir(
        handle: *mut alpm_handle_t,
        gpgdir: *const c_char,
    ) -> c_int;

    /// Returns whether to use syslog (0 is FALSE, TRUE otherwise).
    pub fn alpm_option_get_usesyslog(handle: *mut alpm_handle_t) -> c_int;

    /// Sets whether to use syslog (0 is FALSE, TRUE otherwise).
    pub fn alpm_option_set_usesyslog(
        handle: *mut alpm_handle_t,
        usesyslog: c_int,
    ) -> c_int;

    /// @name Accessors to the list of no-upgrade files.
    /// These functions modify the list of files which should
    /// not be updated by package installation.
    /// @{
    pub fn alpm_option_get_noupgrades(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_add_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const c_char,
    ) -> c_int;

    pub fn alpm_option_set_noupgrades(
        handle: *mut alpm_handle_t,
        noupgrade: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_remove_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const c_char,
    ) -> c_int;

    pub fn alpm_option_match_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const c_char,
    ) -> c_int;

    /// @name Accessors to the list of no-extract files.
    /// These functions modify the list of filenames which should
    /// be skipped packages which should
    /// not be upgraded by a sysupgrade operation.
    /// @{
    pub fn alpm_option_get_noextracts(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_add_noextract(
        handle: *mut alpm_handle_t,
        path: *const c_char,
    ) -> c_int;

    pub fn alpm_option_set_noextracts(
        handle: *mut alpm_handle_t,
        noextract: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_remove_noextract(
        handle: *mut alpm_handle_t,
        path: *const c_char,
    ) -> c_int;

    pub fn alpm_option_match_noextract(
        handle: *mut alpm_handle_t,
        path: *const c_char,
    ) -> c_int;

    /// @name Accessors to the list of ignored packages.
    /// These functions modify the list of packages that
    /// should be ignored by a sysupgrade.
    /// @{
    pub fn alpm_option_get_ignorepkgs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_add_ignorepkg(
        handle: *mut alpm_handle_t,
        pkg: *const c_char,
    ) -> c_int;

    pub fn alpm_option_set_ignorepkgs(
        handle: *mut alpm_handle_t,
        ignorepkgs: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_remove_ignorepkg(
        handle: *mut alpm_handle_t,
        pkg: *const c_char,
    ) -> c_int;

    /// @name Accessors to the list of ignored groups.
    /// These functions modify the list of groups whose packages
    /// should be ignored by a sysupgrade.
    /// @{
    pub fn alpm_option_get_ignoregroups(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_add_ignoregroup(
        handle: *mut alpm_handle_t,
        grp: *const c_char,
    ) -> c_int;

    pub fn alpm_option_set_ignoregroups(
        handle: *mut alpm_handle_t,
        ignoregrps: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_remove_ignoregroup(
        handle: *mut alpm_handle_t,
        grp: *const c_char,
    ) -> c_int;

    /// @name Accessors to the list of ignored dependencies.
    /// These functions modify the list of dependencies that
    /// should be ignored by a sysupgrade.
    /// @{
    pub fn alpm_option_get_assumeinstalled(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    pub fn alpm_option_add_assumeinstalled(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> c_int;

    pub fn alpm_option_set_assumeinstalled(
        handle: *mut alpm_handle_t,
        deps: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_option_remove_assumeinstalled(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> c_int;

    /// Returns the targeted architecture.
    pub fn alpm_option_get_arch(handle: *mut alpm_handle_t) -> *const c_char;

    /// Sets the targeted architecture.
    pub fn alpm_option_set_arch(
        handle: *mut alpm_handle_t,
        arch: *const c_char,
    ) -> c_int;

    pub fn alpm_option_get_deltaratio(handle: *mut alpm_handle_t) -> f64;

    pub fn alpm_option_set_deltaratio(
        handle: *mut alpm_handle_t,
        ratio: f64,
    ) -> c_int;

    pub fn alpm_option_get_checkspace(handle: *mut alpm_handle_t) -> c_int;

    pub fn alpm_option_set_checkspace(
        handle: *mut alpm_handle_t,
        checkspace: c_int,
    ) -> c_int;

    pub fn alpm_option_get_dbext(handle: *mut alpm_handle_t) -> *const c_char;

    pub fn alpm_option_set_dbext(
        handle: *mut alpm_handle_t,
        dbext: *const c_char,
    ) -> c_int;

    pub fn alpm_option_get_default_siglevel(handle: *mut alpm_handle_t) -> c_int;

    pub fn alpm_option_set_default_siglevel(
        handle: *mut alpm_handle_t,
        level: c_int,
    ) -> c_int;

    pub fn alpm_option_get_local_file_siglevel(handle: *mut alpm_handle_t)
        -> c_int;

    pub fn alpm_option_set_local_file_siglevel(
        handle: *mut alpm_handle_t,
        level: c_int,
    ) -> c_int;

    pub fn alpm_option_get_remote_file_siglevel(
        handle: *mut alpm_handle_t,
    ) -> c_int;

    pub fn alpm_option_set_remote_file_siglevel(
        handle: *mut alpm_handle_t,
        level: c_int,
    ) -> c_int;

    pub fn alpm_option_set_disable_dl_timeout(
        handle: *mut alpm_handle_t,
        disable_dl_timeout: c_ushort,
    ) -> c_int;

    /// Get the database of locally installed packages.
    /// The returned pointer points to an internal structure
    /// of libalpm which should only be manipulated through
    /// libalpm functions.
    /// Returns a reference to the local database
    pub fn alpm_get_localdb(handle: *mut alpm_handle_t) -> *mut alpm_db_t;

    /// Get the list of sync databases.
    /// Returns a list of alpm_db_t structures, one for each registered
    /// sync database.
    ///
    /// Returns a reference to an internal list of alpm_db_t structures
    pub fn alpm_get_syncdbs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    /// Register a sync database of packages.
    ///
    /// @param treename the name of the sync repository
    /// @param level what level of signature checking to perform on the
    /// database; note that this must be a '.sig' file type verification
    /// Returns an alpm_db_t* on success (the value), NULL on error
    pub fn alpm_register_syncdb(
        handle: *mut alpm_handle_t,
        treename: *const c_char,
        level: c_int,
    ) -> *mut alpm_db_t;

    /// Unregister all package databases.
    ///
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_unregister_all_syncdbs(handle: *mut alpm_handle_t) -> c_int;

    /// Unregister a package database.
    /// @param db pointer to the package database to unregister
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_db_unregister(db: *mut alpm_db_t) -> c_int;

    /// Get the name of a package database.
    /// @param db pointer to the package database
    /// Returns the name of the package database, NULL on error
    pub fn alpm_db_get_name(db: *const alpm_db_t) -> *const c_char;

    /// Get the signature verification level for a database.
    /// Will return the default verification level if this database is set up
    /// with ALPM_SIG_USE_DEFAULT.
    /// @param db pointer to the package database
    /// Returns the signature verification level
    pub fn alpm_db_get_siglevel(db: *mut alpm_db_t) -> c_int;

    /// Check the validity of a database.
    /// This is most useful for sync databases and verifying signature status.
    /// If invalid, the handle error code will be set accordingly.
    /// @param db pointer to the package database
    /// Returns 0 if valid, -1 if invalid (pm_errno is set accordingly)
    pub fn alpm_db_get_valid(db: *mut alpm_db_t) -> c_int;

    /// @name Accessors to the list of servers for a database.
    /// @{
    pub fn alpm_db_get_servers(db: *const alpm_db_t) -> *mut alpm_list_t;

    pub fn alpm_db_set_servers(
        db: *mut alpm_db_t,
        servers: *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_db_add_server(
        db: *mut alpm_db_t,
        url: *const c_char,
    ) -> c_int;

    pub fn alpm_db_remove_server(
        db: *mut alpm_db_t,
        url: *const c_char,
    ) -> c_int;

    /// @}
    pub fn alpm_db_update(
        force: c_int,
        db: *mut alpm_db_t,
    ) -> c_int;

    /// Get a package entry from a package database.
    /// @param db pointer to the package database to get the package from
    /// @param name of the package
    /// Returns the package entry on success, NULL on error
    pub fn alpm_db_get_pkg(
        db: *mut alpm_db_t,
        name: *const c_char,
    ) -> *mut alpm_pkg_t;

    /// Get the package cache of a package database.
    /// @param db pointer to the package database to get the package from
    /// Returns the list of packages on success, NULL on error
    pub fn alpm_db_get_pkgcache(db: *mut alpm_db_t) -> *mut alpm_list_t;

    /// Get a group entry from a package database.
    /// @param db pointer to the package database to get the group from
    /// @param name of the group
    /// Returns the groups entry on success, NULL on error
    pub fn alpm_db_get_group(
        db: *mut alpm_db_t,
        name: *const c_char,
    ) -> *mut alpm_group_t;

    /// Get the group cache of a package database.
    /// @param db pointer to the package database to get the group from
    /// Returns the list of groups on success, NULL on error
    pub fn alpm_db_get_groupcache(db: *mut alpm_db_t) -> *mut alpm_list_t;

    /// Searches a database with regular expressions.
    /// @param db pointer to the package database to search in
    /// @param needles a list of regular expressions to search for
    /// Returns the list of packages matching all regular expressions on success, NULL on error
    pub fn alpm_db_search(db: *mut alpm_db_t, needles: *const alpm_list_t) -> *mut alpm_list_t;
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_db_usage_t {
    ALPM_DB_USAGE_SYNC      = 0b0001,
    ALPM_DB_USAGE_SEARCH    = 0b0010,
    ALPM_DB_USAGE_INSTALL   = 0b0100,
    ALPM_DB_USAGE_UPGRADE   = 0b1000,
    ALPM_DB_USAGE_ALL       = 0b1111,
}

extern "C" {
    /// Sets the usage of a database.
    /// @param db pointer to the package database to set the status for
    /// @param usage a bitmask of alpm_db_usage_t values
    /// Returns 0 on success, or -1 on error
    pub fn alpm_db_set_usage(
        db: *mut alpm_db_t,
        usage: c_int,
    ) -> c_int;

    /// Gets the usage of a database.
    /// @param db pointer to the package database to get the status of
    /// @param usage pointer to an alpm_db_usage_t to store db's status
    /// Returns 0 on success, or -1 on error
    pub fn alpm_db_get_usage(
        db: *mut alpm_db_t,
        usage: *mut c_int,
    ) -> c_int;

    /// Create a package from a file.
    /// If full is false, the archive is read only until all necessary
    /// metadata is found. If it is true, the entire archive is read, which
    /// serves as a verification of integrity and the filelist can be created.
    /// The allocated structure should be freed using alpm_pkg_free().
    ///
    /// @param filename location of the package tarball
    /// @param full whether to stop the load after metadata is read or continue
    /// through the full archive
    /// @param level what level of package signature checking to perform on the
    /// package; note that this must be a '.sig' file type verification
    /// @param pkg address of the package pointer
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_pkg_load(
        handle: *mut alpm_handle_t,
        filename: *const c_char,
        full: c_int,
        level: c_int,
        pkg: *mut *mut alpm_pkg_t,
    ) -> c_int;

    /// Find a package in a list by name.
    /// @param haystack a list of alpm_pkg_t
    /// @param needle the package name
    /// Returns a pointer to the package if found or NULL
    pub fn alpm_pkg_find(
        haystack: *mut alpm_list_t,
        needle: *const c_char,
    ) -> *mut alpm_pkg_t;

    /// Free a package.
    /// @param pkg package pointer to free
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_pkg_free(pkg: *mut alpm_pkg_t) -> c_int;

    /// Check the integrity (with md5) of a package from the sync cache.
    /// @param pkg package pointer
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_pkg_checkmd5sum(pkg: *mut alpm_pkg_t) -> c_int;

    /// Compare two version strings and determine which one is 'newer'.
    pub fn alpm_pkg_vercmp(
        a: *const c_char,
        b: *const c_char,
    ) -> c_int;

    /// Computes the list of packages requiring a given package.
    /// The return value of this function is a newly allocated
    /// list of package names (char*), it should be freed by the caller.
    /// @param pkg a package
    /// Returns the list of packages requiring pkg
    pub fn alpm_pkg_compute_requiredby(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Computes the list of packages optionally requiring a given package.
    /// The return value of this function is a newly allocated
    /// list of package names (char*), it should be freed by the caller.
    /// @param pkg a package
    /// Returns the list of packages optionally requiring pkg
    pub fn alpm_pkg_compute_optionalfor(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Test if a package should be ignored.
    /// Checks if the package is ignored via IgnorePkg, or if the package is
    /// in a group ignored via IgnoreGroup.
    ///
    /// @param pkg the package to test
    /// Returns 1 if the package should be ignored, 0 otherwise
    pub fn alpm_pkg_should_ignore(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> c_int;

    /// Gets the name of the file from which the package was loaded.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_filename(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the package base name.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_base(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the package name.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_name(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the package version as a string.
    /// This includes all available epoch, version, and pkgrel components. Use
    /// alpm_pkg_vercmp() to compare version strings if necessary.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_version(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the origin of the package.
    /// Returns an alpm_pkgfrom_t constant, -1 on error
    pub fn alpm_pkg_get_origin(pkg: *mut alpm_pkg_t) -> alpm_pkgfrom_t;

    /// Returns the package description.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_desc(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the package URL.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_url(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the build timestamp of the package.
    /// @param pkg a pointer to package
    /// Returns the timestamp of the build time
    pub fn alpm_pkg_get_builddate(pkg: *mut alpm_pkg_t) -> alpm_time_t;

    /// Returns the install timestamp of the package.
    /// @param pkg a pointer to package
    /// Returns the timestamp of the install time
    pub fn alpm_pkg_get_installdate(pkg: *mut alpm_pkg_t) -> alpm_time_t;

    /// Returns the packager's name.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_packager(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the package's MD5 checksum as a string.
    /// The returned string is a sequence of 32 lowercase hexadecimal digits.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_md5sum(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the package's SHA256 checksum as a string.
    /// The returned string is a sequence of 64 lowercase hexadecimal digits.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_sha256sum(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the architecture for which the package was built.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_arch(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the size of the package. This is only available for sync database
    /// packages and package files, not those loaded from the local database.
    /// @param pkg a pointer to package
    /// Returns the size of the package in bytes.
    pub fn alpm_pkg_get_size(pkg: *mut alpm_pkg_t) -> off_t;

    /// Returns the installed size of the package.
    /// @param pkg a pointer to package
    /// Returns the total size of files installed by the package.
    pub fn alpm_pkg_get_isize(pkg: *mut alpm_pkg_t) -> off_t;

    /// Returns the package installation reason.
    /// @param pkg a pointer to package
    /// Returns an enum member giving the install reason.
    pub fn alpm_pkg_get_reason(pkg: *mut alpm_pkg_t) -> alpm_pkgreason_t;

    /// Returns the list of package licenses.
    /// @param pkg a pointer to package
    /// Returns a pointer to an internal list of strings.
    pub fn alpm_pkg_get_licenses(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of package groups.
    /// @param pkg a pointer to package
    /// Returns a pointer to an internal list of strings.
    pub fn alpm_pkg_get_groups(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of package dependencies as alpm_depend_t.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_depends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of package optional dependencies.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_optdepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns a list of package check dependencies
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_checkdepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns a list of package make dependencies
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_makedepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of packages conflicting with pkg.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_conflicts(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of packages provided by pkg.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_provides(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of available deltas for pkg.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of strings.
    pub fn alpm_pkg_get_deltas(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of packages to be replaced by pkg.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal list of alpm_depend_t structures.
    pub fn alpm_pkg_get_replaces(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the list of files installed by pkg.
    /// The filenames are relative to the install root,
    /// and do not include leading slashes.
    /// @param pkg a pointer to package
    /// Returns a pointer to a filelist object containing a count and an array of
    /// package file objects
    pub fn alpm_pkg_get_files(pkg: *mut alpm_pkg_t) -> *mut alpm_filelist_t;

    /// Returns the list of files backed up when installing pkg.
    /// @param pkg a pointer to package
    /// Returns a reference to a list of alpm_backup_t objects
    pub fn alpm_pkg_get_backup(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Returns the database containing pkg.
    /// Returns a pointer to the alpm_db_t structure the package is
    /// originating from, or NULL if the package was loaded from a file.
    /// @param pkg a pointer to package
    /// Returns a pointer to the DB containing pkg, or NULL.
    pub fn alpm_pkg_get_db(pkg: *mut alpm_pkg_t) -> *mut alpm_db_t;

    /// Returns the base64 encoded package signature.
    /// @param pkg a pointer to package
    /// Returns a reference to an internal string
    pub fn alpm_pkg_get_base64_sig(pkg: *mut alpm_pkg_t) -> *const c_char;

    /// Returns the method used to validate a package during install.
    /// @param pkg a pointer to package
    /// Returns an enum member giving the validation method
    pub fn alpm_pkg_get_validation(pkg: *mut alpm_pkg_t) -> c_int;

    /// Open a package changelog for reading.
    /// Similar to fopen in functionality, except that the returned 'file
    /// stream' could really be from an archive as well as from the database.
    /// @param pkg the package to read the changelog of (either file or db)
    /// Returns a 'file stream' to the package changelog
    pub fn alpm_pkg_changelog_open(pkg: *mut alpm_pkg_t) -> *mut c_void;

    /// Read data from an open changelog 'file stream'.
    /// Similar to fread in functionality, this function takes a buffer and
    /// amount of data to read. If an error occurs pm_errno will be set.
    /// @param ptr a buffer to fill with raw changelog data
    /// @param size the size of the buffer
    /// @param pkg the package that the changelog is being read from
    /// @param fp a 'file stream' to the package changelog
    /// Returns the number of characters read, or 0 if there is no more data or an
    /// error occurred.
    pub fn alpm_pkg_changelog_read(
        ptr: *mut c_void,
        size: usize,
        pkg: *const alpm_pkg_t,
        fp: *mut c_void,
    ) -> usize;

    pub fn alpm_pkg_changelog_close(
        pkg: *const alpm_pkg_t,
        fp: *mut c_void,
    ) -> c_int;

    /// Open a package mtree file for reading.
    /// @param pkg the local package to read the changelog of
    /// Returns a archive structure for the package mtree file
    pub fn alpm_pkg_mtree_open(pkg: *mut alpm_pkg_t) -> *mut archive;

    /// Read next entry from a package mtree file.
    /// @param pkg the package that the mtree file is being read from
    /// @param archive the archive structure reading from the mtree file
    /// @param entry an archive_entry to store the entry header information
    /// Returns 0 if end of archive is reached, non-zero otherwise.
    pub fn alpm_pkg_mtree_next(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
        entry: *mut *mut archive_entry,
    ) -> c_int;

    pub fn alpm_pkg_mtree_close(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
    ) -> c_int;

    /// Returns whether the package has an install scriptlet.
    /// Returns 0 if FALSE, TRUE otherwise
    pub fn alpm_pkg_has_scriptlet(pkg: *mut alpm_pkg_t) -> c_int;

    /// Returns the size of download.
    /// Returns the size of the files that will be downloaded to install a
    /// package.
    /// @param newpkg the new package to upgrade to
    /// Returns the size of the download
    pub fn alpm_pkg_download_size(newpkg: *mut alpm_pkg_t) -> off_t;

    pub fn alpm_pkg_unused_deltas(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;

    /// Set install reason for a package in the local database.
    /// The provided package object must be from the local database or this method
    /// will fail. The write to the local database is performed immediately.
    /// @param pkg the package to update
    /// @param reason the new install reason
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_pkg_set_reason(
        pkg: *mut alpm_pkg_t,
        reason: alpm_pkgreason_t,
    ) -> c_int;

    /// Determines whether a package filelist contains a given path.
    /// The provided path should be relative to the install root with no leading
    /// slashes, e.g. "etc/localtime". When searching for directories, the path must
    /// have a trailing slash.
    /// @param filelist a pointer to a package filelist
    /// @param path the path to search for in the package
    /// Returns a pointer to the matching file or NULL if not found
    pub fn alpm_filelist_contains(
        filelist: *mut alpm_filelist_t,
        path: *const c_char,
    ) -> *mut alpm_file_t;

    pub fn alpm_pkg_check_pgp_signature(
        pkg: *mut alpm_pkg_t,
        siglist: *mut alpm_siglist_t,
    ) -> c_int;

    pub fn alpm_db_check_pgp_signature(
        db: *mut alpm_db_t,
        siglist: *mut alpm_siglist_t,
    ) -> c_int;

    pub fn alpm_siglist_cleanup(siglist: *mut alpm_siglist_t) -> c_int;

    pub fn alpm_decode_signature(
        base64_data: *const c_char,
        data: *mut *mut c_uchar,
        data_len: *mut usize,
    ) -> c_int;

    pub fn alpm_extract_keyid(
        handle: *mut alpm_handle_t,
        identifier: *const c_char,
        sig: *const c_uchar,
        len: usize,
        keys: *mut *mut alpm_list_t,
    ) -> c_int;

    pub fn alpm_find_group_pkgs(
        dbs: *mut alpm_list_t,
        name: *const c_char,
    ) -> *mut alpm_list_t;

    pub fn alpm_sync_newversion(
        pkg: *mut alpm_pkg_t,
        dbs_sync: *mut alpm_list_t,
    ) -> *mut alpm_pkg_t;
}

/// Transaction flags
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_transflag_t {
    /// Ignore dependency checks.
    ALPM_TRANS_FLAG_NODEPS = 1,
    /// Ignore file conflicts and overwrite files.
    ALPM_TRANS_FLAG_FORCE = (1 << 1),
    /// Delete files even if they are tagged as backup.
    ALPM_TRANS_FLAG_NOSAVE = (1 << 2),
    /// Ignore version numbers when checking dependencies.
    ALPM_TRANS_FLAG_NODEPVERSION = (1 << 3),
    /// Remove also any packages depending on a package being removed.
    ALPM_TRANS_FLAG_CASCADE = (1 << 4),
    /// Remove packages and their unneeded deps (not explicitly installed).
    ALPM_TRANS_FLAG_RECURSE = (1 << 5),
    /// Modify database but do not commit changes to the filesystem.
    ALPM_TRANS_FLAG_DBONLY = (1 << 6),

    // (1 << 7) flag can go here

    /// Use ALPM_PKG_REASON_DEPEND when installing packages.
    ALPM_TRANS_FLAG_ALLDEPS = (1 << 8),
    /// Only download packages and do not actually install.
    ALPM_TRANS_FLAG_DOWNLOADONLY = (1 << 9),
    /// Do not execute install scriptlets after installing.
    ALPM_TRANS_FLAG_NOSCRIPTLET = (1 << 10),
    /// Ignore dependency conflicts.
    ALPM_TRANS_FLAG_NOCONFLICTS = (1 << 11),
    // (1 << 12) flag can go here
    /// Do not install a package if it is already installed and up to date.
    ALPM_TRANS_FLAG_NEEDED = (1 << 13),
    /// Use ALPM_PKG_REASON_EXPLICIT when installing packages.
    ALPM_TRANS_FLAG_ALLEXPLICIT = (1 << 14),
    /// Do not remove a package if it is needed by another one.
    ALPM_TRANS_FLAG_UNNEEDED = (1 << 15),
    /// Remove also explicitly installed unneeded deps (use with ALPM_TRANS_FLAG_RECURSE).
    ALPM_TRANS_FLAG_RECURSEALL = (1 << 16),
    /// Do not lock the database during the operation.
    ALPM_TRANS_FLAG_NOLOCK = (1 << 17),
}

extern "C" {
    /// Returns the bitfield of flags for the current transaction.
    ///
    /// Returns the bitfield of transaction flags
    pub fn alpm_trans_get_flags(handle: *mut alpm_handle_t) -> c_int;

    /// Returns a list of packages added by the transaction.
    ///
    /// Returns a list of alpm_pkg_t structures
    pub fn alpm_trans_get_add(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    /// Returns the list of packages removed by the transaction.
    ///
    /// Returns a list of alpm_pkg_t structures
    pub fn alpm_trans_get_remove(handle: *mut alpm_handle_t) -> *mut alpm_list_t;

    /// Initialize the transaction.
    ///
    /// @param flags flags of the transaction (like nodeps, etc; see alpm_transflag_t)
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_trans_init(
        handle: *mut alpm_handle_t,
        flags: c_int,
    ) -> c_int;

    /// Prepare a transaction.
    ///
    /// @param data the address of an alpm_list where a list
    /// of alpm_depmissing_t objects is dumped (conflicting packages)
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_trans_prepare(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> c_int;

    /// Commit a transaction.
    ///
    /// @param data the address of an alpm_list where detailed description
    /// of an error can be dumped (i.e. list of conflicting files)
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_trans_commit(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> c_int;

    /// Interrupt a transaction.
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_trans_interrupt(handle: *mut alpm_handle_t) -> c_int;

    /// Release a transaction.
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_trans_release(handle: *mut alpm_handle_t) -> c_int;

    /// Search for packages to upgrade and add them to the transaction.
    /// If enable_downgrade is true, allow downgrading of packages if the remote version is lower
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_sync_sysupgrade(
        handle: *mut alpm_handle_t,
        enable_downgrade: c_int,
    ) -> c_int;

    /// Add a package to the transaction.
    /// 
    /// If the package was loaded by `alpm_pkg_load()`, it will be freed upon
    /// `alpm_trans_release()` invocation.
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_add_pkg(handle: *mut alpm_handle_t, pkg: *mut alpm_pkg_t) -> c_int;

    /// Add a package removal action to the transaction.
    /// Returns 0 on success, -1 on error (pm_errno is set accordingly)
    pub fn alpm_remove_pkg(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> c_int;

    pub fn alpm_checkdeps(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
        remove: *mut alpm_list_t,
        upgrade: *mut alpm_list_t,
        reversedeps: c_int,
    ) -> *mut alpm_list_t;

    pub fn alpm_find_satisfier(
        pkgs: *mut alpm_list_t,
        depstring: *const c_char,
    ) -> *mut alpm_pkg_t;

    pub fn alpm_find_dbs_satisfier(
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        depstring: *const c_char,
    ) -> *mut alpm_pkg_t;

    pub fn alpm_checkconflicts(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
    ) -> *mut alpm_list_t;

    /// Returns a newly allocated string representing the dependency information.
    pub fn alpm_dep_compute_string(dep: *const alpm_depend_t) -> *mut c_char;

    /// Return a newly allocated dependency information parsed from a string.
    pub fn alpm_dep_from_string(depstring: *const c_char) -> *mut alpm_depend_t;

    /// Free a dependency info structure
    pub fn alpm_dep_free(dep: *mut alpm_depend_t);

    pub fn alpm_compute_md5sum(
        filename: *const c_char,
    ) -> *mut c_char;

    pub fn alpm_compute_sha256sum(
        filename: *const c_char,
    ) -> *mut c_char;

    pub fn alpm_initialize(
        root: *const c_char,
        dbpath: *const c_char,
        err: *mut alpm_errno_t,
    ) -> *mut alpm_handle_t;

    pub fn alpm_release(handle: *mut alpm_handle_t) -> c_int;

    pub fn alpm_unlock(handle: *mut alpm_handle_t) -> c_int;
}

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum alpm_caps {
    ALPM_CAPABILITY_NLS = 1,
    ALPM_CAPABILITY_DOWNLOADER = 2,
    ALPM_CAPABILITY_SIGNATURES = 4,
}

extern "C" {
    pub fn alpm_version() -> *const c_char;

    pub fn alpm_capabilities() -> alpm_caps;

    pub fn alpm_fileconflict_free(conflict: *mut alpm_fileconflict_t);

    pub fn alpm_depmissing_free(miss: *mut alpm_depmissing_t);

    pub fn alpm_conflict_free(conflict: *mut alpm_conflict_t);
}
